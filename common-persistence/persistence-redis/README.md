
## 1. Redis删除策略

### 1.1. 惰性删除


### 1.2. 定时删除

## 2. 过期数据

![20211115154057](https://abram.oss-cn-shanghai.aliyuncs.com/blog/redis/20211115154057.png)

有这样一种场景，**应用1** 向主节点写数据，并且设置失效时间。

### 2.1. 读取 `Master`

应用数据已经过期，主库的惰性删除会发生作用，主动对该数据进行删除操作，保证 客户端应用不会拿到过期的数据

### 2.2. 读取 `Slave`

如果 读取的是 `Slave` 库，则有可能会拿到过期数据，一般造成这样原因有两个：

#### 2.2.1. 版本过低

这样的场景由于 `Redis` 控制不住过期数据被客户端应用误读，形成数据不安全。但是 `Redis` 从 3.2 版本后，对此类场景的数据问题做过滤，并且返回空值。所以 如果有应用此场景，需要对 `Redis` 进行升级操作。

#### 2.2.2. 过期时间设置

与过期时间设置方式有关系，一般我们采用 `EXPIRE` 和 `PEXPIRE`，都表示从执行命令那个时刻即 **开始时间** 开始，往后延长 `ttl` 时间，严重依赖于 **开始时间** 从什么时候算起。

![20211115155642](https://abram.oss-cn-shanghai.aliyuncs.com/blog/redis/20211115155642.png)

上图描述的过程大致如下：

- `Master` 在 t1 时刻写入一个带过期时间的数据，数据的有效期一直到 t3
- 由于网络波动或者所在服务器自身执行问题，`Slave` 实际执行开始时间为 t2，数据有效期一直到 t5。
- 如果客户端应用在 t3 至 t4 时间段内访问，则可能获取到过期时间。
  
一般此种场景解决方案就是要求 主从节点服务器NTP时间服务保持时钟同步

## 3. 主从不一致

![20211115161513](https://abram.oss-cn-shanghai.aliyuncs.com/blog/redis/20211115161513.png)

上图描述的过程大致如下：

- 在 `T1` 时间点，主库将主键 `key1` 的内容改为 `100`，此时通过主从异步同步，从库中的 `key1` 会拿到该数据
- 在 `T2` 时间点，主库将主键 `key1` 的内容改为 `200`，此时由于主从之间的网络问题，或者服务器正在处理 pipline 批处理操作，无法及时同步执行。

针对上述问题，我们建议针对 redis 部署有如下要求：

- 主从服务器尽量部署在同一个机房，并保持服务器间的网络良好通畅
- 监控主从库间的同步进度，通过 `info replication` 命令 ，查看主库接收写命令的进度信息（`master_repl_offset`），从库的复制写命令的进度信息（`slave_repl_offset`）